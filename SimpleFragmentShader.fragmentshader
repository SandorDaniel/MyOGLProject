// TODO: Testing specular color on a spehere
// TODO: Testing inhomogeneous material
// TODO: uniformization of light datas, CPU-side Light class
// TODO: material (find out the best practice for this topic)
// TODO: multiple lights (array)

#version 330 core



float angleBetweenVectorsInRadians(in vec3 u, in vec3 v)
{
	return acos(dot(u, v) / (length(u) * length(v)));
}


vec3 colFrom(
	in vec4  source_light_posdir,
	in vec3  positional_source_light_dir,
	in float positional_light_angle_in_radians,
	in float source_light_power,
	in vec3  source_light_diffuse_col,
	in vec3  source_light_specular_col,
	in vec3  source_light_ambient_col,
	in vec3  out_vert_pos,
	in vec3  out_vert_nor,
	in vec3  nor,
	in vec3  material_diffuse_col,
	in vec3  material_specular_col,
	in vec3  material_ambient_col,
	in vec3  cam_pos)
{
	float distance_factor;
	source_light_power;
	vec3 source_light_dir;
	{
		if(source_light_posdir.w != 0) // Positional light source
		{
			vec3 source_light_pos = (source_light_posdir / source_light_posdir.w).xyz;

			float distance = length(source_light_pos - out_vert_pos);
			distance_factor = distance * distance;

			source_light_dir = normalize(source_light_pos - out_vert_pos);

			if(angleBetweenVectorsInRadians(-source_light_dir, positional_source_light_dir) > positional_light_angle_in_radians)
			{
				source_light_power = 0.0f;
			}
		}
		else // Directional light source
		{
			distance_factor = 1.0f;

			source_light_dir = -normalize(source_light_posdir.xyz);
		}
	}

	if(angleBetweenVectorsInRadians(out_vert_nor, source_light_dir) > 3.14f / 1.75f) // TODO: After implementing shadow mapping, rethig the neccesity of this block.
	{
		return material_ambient_col * source_light_ambient_col / distance_factor;
	}

	// Normal of the computed fragment, in camera space
	vec3 n = normalize(nor);
	// Direction of the light (from the fragment to the light)
	vec3 l = normalize(source_light_dir);
	// Cosine of the angle between the normal and the light direction, 
	// clamped above 0
	//  - light is at the vertical of the triangle -> 1
	//  - light is perpendicular to the triangle -> 0
	//  - light is behind the triangle -> 0
	float cosTheta = clamp(dot(n, l), 0, 1);

	// Eye vector (towards the camera)
	vec3 E = normalize(cam_pos - out_vert_pos);
	// Direction in which the triangle reflects the light
	vec3 R = reflect(-l, n);
	// Cosine of the angle between the Eye vector and the Reflect vector,
	// clamped to 0
	//  - Looking into the reflection -> 1
	//  - Looking elsewhere -> < 1
	float cosAlpha = clamp(dot(E, R), 0, 1);

	return
		// Ambient : simulates indirect lighting
		material_ambient_col  * source_light_ambient_col                                          / distance_factor
		// Diffuse : "color" of the object
      + material_diffuse_col  * source_light_diffuse_col  * source_light_power * cosTheta         / distance_factor
		// Specular : reflective highlight, like a mirror
      + material_specular_col * source_light_specular_col * source_light_power * pow(cosAlpha, 5) / distance_factor;
}



uniform sampler2D tex_matdiff_sampler;
uniform sampler2D tex_matspec_sampler;
uniform sampler2D tex_norm_sampler;

const int num_of_light_sources = 2; // TODO: get it from cpu somehow

uniform float source_light_power[num_of_light_sources];
uniform vec4  source_light_posdir[num_of_light_sources];

uniform float positional_light_angle_in_radians[num_of_light_sources]; 
uniform vec3 positional_source_light_dir[num_of_light_sources];

uniform vec3  source_light_diffuse_col[num_of_light_sources];
uniform vec3  source_light_specular_col[num_of_light_sources];
uniform vec3  source_light_ambient_col[num_of_light_sources];


uniform vec3  cam_pos = vec3(0.0f, 0.0f, 5.0f);


in vec3 out_vert_pos;
in vec2 out_vert_tex;
in mat3 out_vert_TBN;
vec3 norm = normalize(out_vert_TBN * (2 * texture(tex_norm_sampler, out_vert_tex.st).rgb - vec3(1.0f, 1.0f, 1.0f)));


vec3  material_diffuse_col  = texture(tex_matdiff_sampler, out_vert_tex.st).rgb; // col of the texture at the specified st
vec3  material_ambient_col  = 0.0005f * material_diffuse_col;
vec3  material_specular_col = texture(tex_matspec_sampler, out_vert_tex.st).rgb;


out vec4 col;



void main()
{
	vec3 color = vec3(0.0f, 0.0f, 0.0f);

	for(int i = 0; i < num_of_light_sources; ++i)
	{
		color += colFrom(source_light_posdir[i],
	                     positional_source_light_dir[i],
						 positional_light_angle_in_radians[i],
		                 source_light_power[i],
		                 source_light_diffuse_col[i],
		                 source_light_specular_col[i],
		                 source_light_ambient_col[i],
		                 out_vert_pos,
						 out_vert_TBN[2],
		                 norm,
		                 material_diffuse_col,
		                 material_specular_col,
		                 material_ambient_col,
						 cam_pos);
	}

	col = vec4(color, 1.0f);
}
